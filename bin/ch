#!/usr/bin/env node
import { spawnSync } from "child_process";
import { homedir } from "os";
import { basename, delimiter, dirname, isAbsolute, join, relative, resolve, sep } from "path";
import readline from "readline";
import {
  existsSync,
  mkdirSync,
  readdirSync,
  readFileSync,
  readlinkSync,
  realpathSync,
  rmSync,
  statSync,
  symlinkSync,
  writeFileSync,
} from "fs";

const HOME_DIR = process.env.HOME || homedir();
const DEFAULT_ROOT = process.env.GC_ROOT || join(HOME_DIR, "projects", "checkpoints");
const CHECKPOINTS_HELP = `Checkpoints live at ${DEFAULT_ROOT}/<repo> by default.
Set GC_ROOT to change the base directory (e.g. "export GC_ROOT=~/projects/checkpoints").`;
const INDEX_FILE = ".gc-index.json";
const DEFAULT_COMMAND = "ch";

function commandName() {
  return basename(process.argv[1] || DEFAULT_COMMAND);
}

function usage() {
  const self = commandName();
  console.log(`Usage:
  ${self} clone <repo-path-or-name> [target-dir]
  ${self} clone --copy <repo-path-or-name> [target-dir]
  ${self} clone --dest <dir> <repo-path-or-name> [target-dir]
  ${self} clone --prefix <name> <repo-path-or-name>
  ${self} list <repo>
  ${self} current <repo>
  ${self} switch <repo> <name-or-number>
  ${self} switch
  ${self} delete
  ${self} delete <repo> <name-or-number>
  ${self} clean <repo> [--days <n>] [--dry-run]
  ${self} path <repo> <name-or-number>
  ${self} latest <repo>

Examples:
  ${self} clone fafo
  ${self} clone --dest ${DEFAULT_ROOT} fafo
  ${self} list fafo
  ${self} switch fafo 2
  ${self} switch
  ${self} delete
  ${self} delete fafo 2
  ${self} clean fafo --days 90
  ${self} current fafo
  cd "$(${self} path fafo 2)"

Notes:
  By default clone makes a full copy (tracked + untracked + ignored). Use
  "clone --clone" for a local git clone of tracked files only.
  Default output location is ${DEFAULT_ROOT}/<repo>/<repo>-N
  (or ${DEFAULT_ROOT}/<repo>/<prefix>-N if --prefix is set).
  ${CHECKPOINTS_HELP}`);
}

function die(msg, code = 1) {
  process.stderr.write(`error: ${msg}\n`);
  process.exit(code);
}

function isDir(p) {
  try {
    return statSync(p).isDirectory();
  } catch {
    return false;
  }
}

function run(cmd, cwd) {
  const [bin, ...args] = cmd;
  const res = spawnSync(bin, args, {
    cwd,
    stdio: ["ignore", "pipe", "pipe"],
  });
  if (res.error) {
    if (res.error.code === "ENOENT") {
      die(`command not found: ${bin}`);
    }
    die(res.error.message);
  }
  const exitCode = res.status ?? (res.signal ? 1 : 0);
  if (exitCode !== 0) {
    if (res.stderr?.length) {
      process.stderr.write(res.stderr);
    }
    process.exit(exitCode);
  }
  return res;
}

function supportsRsyncInfoProgress(rsyncPath) {
  const res = spawnSync(rsyncPath, ["--info=progress2", "--version"], {
    stdio: ["ignore", "ignore", "ignore"],
  });
  return res.status === 0;
}

function installEscapeHandler() {
  const onKey = (_value, key) => {
    if (key && key.name === "escape") {
      process.stdout.write("\x1B[?25h\n");
      process.exit(130);
    }
  };
  readline.emitKeypressEvents(process.stdin);
  process.stdin.on("keypress", onKey);
  return () => process.stdin.off("keypress", onKey);
}

function listCheckpoints(baseDir) {
  if (!isDir(baseDir)) return [];
  return readdirSync(baseDir, { withFileTypes: true })
    .filter((d) => d.isDirectory() && d.name !== "current")
    .map((d) => d.name)
    .sort((a, b) => a.localeCompare(b, "en", { numeric: true }));
}

function loadIndex(baseDir) {
  const indexPath = join(baseDir, INDEX_FILE);
  if (!existsSync(indexPath)) return { items: [] };
  try {
    const data = JSON.parse(readFileSync(indexPath, "utf8"));
    if (data && Array.isArray(data.items)) return { items: data.items };
  } catch {
    // fall through to empty index
  }
  return { items: [] };
}

function saveIndex(baseDir, items) {
  const indexPath = join(baseDir, INDEX_FILE);
  const payload = { version: 1, items };
  writeFileSync(indexPath, `${JSON.stringify(payload, null, 2)}\n`);
}

function ensureIndex(baseDir, names) {
  const index = loadIndex(baseDir);
  const map = new Map(index.items.map((item) => [item.name, item]));
  let changed = false;
  const info = [];

  for (const name of names) {
    let mtimeMs = 0;
    try {
      const stat = statSync(join(baseDir, name));
      mtimeMs = stat.mtimeMs;
    } catch {
      mtimeMs = Date.now();
    }

    const existing = map.get(name);
    const createdAt = existing?.createdAt || new Date(mtimeMs).toISOString();
    const lastModified = new Date(mtimeMs).toISOString();

    if (!existing || !existing.createdAt || existing.lastModified !== lastModified) {
      map.set(name, { name, createdAt, lastModified });
      changed = true;
    }

    info.push({ name, createdAt, lastModified, mtimeMs });
  }

  const items = Array.from(map.values());
  if (changed) saveIndex(baseDir, items);
  return info;
}

function recordCheckpoint(baseDir, name) {
  const index = loadIndex(baseDir);
  const now = new Date().toISOString();
  const existing = index.items.find((item) => item.name === name);
  if (existing) {
    existing.createdAt = existing.createdAt || now;
    existing.lastModified = now;
  } else {
    index.items.push({ name, createdAt: now, lastModified: now });
  }
  saveIndex(baseDir, index.items);
}

function formatAge(ms) {
  const seconds = Math.max(0, Math.floor(ms / 1000));
  if (seconds < 60) return `${seconds}s ago`;
  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) return `${minutes}m ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 48) return `${hours}h ago`;
  const days = Math.floor(hours / 24);
  if (days < 30) return `${days}d ago`;
  const months = Math.floor(days / 30);
  if (months < 24) return `${months}mo ago`;
  const years = Math.floor(months / 12);
  return `${years}y ago`;
}

function formatStamp(value) {
  const ts = Date.parse(value || "");
  if (!Number.isFinite(ts)) return value || "";
  try {
    return new Intl.DateTimeFormat(undefined, {
      year: "numeric",
      month: "short",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
    }).format(new Date(ts));
  } catch {
    return new Date(ts).toLocaleString();
  }
}

function currentCheckpointName(baseDir) {
  const currentLink = join(baseDir, "current");
  if (existsSync(currentLink)) {
    try {
      return basename(readlinkSync(currentLink));
    } catch {
      return "";
    }
  }
  return "";
}

function listWithActivity(baseDir, output = process.stdout) {
  const names = listCheckpoints(baseDir);
  if (names.length === 0) {
    process.stderr.write("no checkpoints found\n");
    return;
  }
  const nameSet = new Set(names);
  const indexed = ensureIndex(baseDir, names).filter((item) => nameSet.has(item.name));
  const now = Date.now();
  const currentName = currentCheckpointName(baseDir);
  for (const item of indexed.sort((a, b) => a.name.localeCompare(b.name, "en", { numeric: true }))) {
    const age = formatAge(now - item.mtimeMs);
    const stamp = formatStamp(item.lastModified || new Date(item.mtimeMs).toISOString());
    const mark = item.name === currentName ? "*" : " ";
    output.write(`${mark} ${item.name}  ${age}  (${stamp})\n`);
  }
}

async function loadInquirer() {
  try {
    const mod = await import("inquirer");
    return mod.default || mod;
  } catch {
    die('inquirer not installed. run "npm install" in ~/git-checkpoint');
  }
}

function which(cmd) {
  const hasPathSep = cmd.includes("/") || cmd.includes("\\");
  if (hasPathSep) {
    return existsSync(cmd) && statSync(cmd).isFile() ? cmd : "";
  }

  const exts =
    process.platform === "win32"
      ? (process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM").split(";")
      : [""];
  const paths = (process.env.PATH || "").split(delimiter).filter(Boolean);
  for (const dir of paths) {
    for (const ext of exts) {
      const candidate = join(dir, `${cmd}${ext}`);
      if (existsSync(candidate) && statSync(candidate).isFile()) {
        return candidate;
      }
    }
  }
  return "";
}

async function promptList(message, choices) {
  const inquirer = await loadInquirer();
  const cleanup = installEscapeHandler();
  try {
    const { value } = await inquirer.prompt([
      {
        type: "list",
        name: "value",
        message,
        pageSize: 12,
        choices,
      },
    ]);
    return value || "";
  } catch {
    return "";
  } finally {
    cleanup();
  }
}

async function pickCheckpointInteractive(baseDir) {
  const names = listCheckpoints(baseDir);
  if (names.length === 0) {
    die("no checkpoints found");
  }

  const nameSet = new Set(names);
  const indexed = ensureIndex(baseDir, names).filter((item) => nameSet.has(item.name));
  const now = Date.now();
  const currentName = currentCheckpointName(baseDir);
  const choices = indexed
    .slice()
    .sort((a, b) => a.name.localeCompare(b.name, "en", { numeric: true }))
    .map((item) => {
      const age = formatAge(now - item.mtimeMs);
      const stamp = formatStamp(item.lastModified || new Date(item.mtimeMs).toISOString());
      const mark = item.name === currentName ? "*" : " ";
      return {
        name: `${mark} ${item.name}  ${age}  (${stamp})`,
        value: item.name,
      };
    });
  return promptList("Select checkpoint", choices);
}

async function pickRepoInteractive() {
  const root = DEFAULT_ROOT;
  if (!existsSync(root)) {
    die("no checkpoints found");
  }
  const repos = readdirSync(root, { withFileTypes: true })
    .filter((entry) => entry.isDirectory())
    .map((entry) => entry.name)
    .sort((a, b) => a.localeCompare(b, "en", { numeric: true }));
  if (repos.length === 0) {
    die("no checkpoints found");
  }
  const choices = repos.map((repo) => ({ name: repo, value: repo }));
  return promptList("Select repo", choices);
}

function resolveName(baseDir, repo, nameOrNumber) {
  if (!nameOrNumber) die("missing checkpoint name or number");
  if (/^\d+$/.test(nameOrNumber)) {
    const candidate = `${repo}-${nameOrNumber}`;
    if (existsSync(join(baseDir, candidate))) return candidate;
  }
  if (existsSync(join(baseDir, nameOrNumber))) return nameOrNumber;
  die(`checkpoint not found: ${nameOrNumber} (try "${commandName()} list ${repo}")`);
}

function resolveCheckpointFromCwd() {
  const root = existsSync(DEFAULT_ROOT) ? realpathSync(DEFAULT_ROOT) : resolve(DEFAULT_ROOT);
  const cwd = realpathSync(process.cwd());
  const rel = relative(root, cwd);
  if (!rel || rel === "." || rel.startsWith("..")) {
    die(`not inside ${root}`);
  }
  const parts = rel.split(sep).filter(Boolean);
  if (parts.length < 2) {
    die("not inside a checkpoint directory");
  }
  const repo = parts[0];
  const name = parts[1];
  const baseDir = join(root, repo);
  return { baseDir, name };
}

function removeCheckpoint(baseDir, name) {
  const target = join(baseDir, name);
  if (!isDir(target)) die(`checkpoint is not a directory: ${name}`);

  const currentLink = join(baseDir, "current");
  if (existsSync(currentLink)) {
    try {
      const currentTarget = readlinkSync(currentLink);
      const resolvedCurrent = realpathSync(currentTarget);
      const resolvedTarget = realpathSync(target);
      if (resolvedCurrent === resolvedTarget) {
        rmSync(currentLink, { force: true });
      }
    } catch {
      // ignore invalid symlink
    }
  }

  rmSync(target, { recursive: true, force: true });

  const existingIndex = loadIndex(baseDir);
  if (existingIndex.items.length) {
    const remaining = existingIndex.items.filter((item) => item.name !== name);
    if (remaining.length !== existingIndex.items.length) {
      saveIndex(baseDir, remaining);
    }
  }
}

const scriptName = commandName();
let args = process.argv.slice(2);

if (scriptName === "ch-clone" && (args[0] !== "clone")) {
  args.unshift("clone");
}

const cmd = args[0];
if (!cmd || cmd === "-h" || cmd === "--help" || cmd === "help") {
  usage();
  process.exit(cmd ? 0 : 1);
}

if (cmd === "clone") {
  args = args.slice(1);
  let mode = "copy";
  let destRoot = "";
  let prefix = "";

  while (args.length > 0) {
    const arg = args[0];
    if (arg === "-h" || arg === "--help") {
      usage();
      process.exit(0);
    }
    if (arg === "--copy") {
      mode = "copy";
      args.shift();
      continue;
    }
    if (arg === "--clone") {
      mode = "clone";
      args.shift();
      continue;
    }
    if (arg === "--dest") {
      const val = args[1];
      if (!val) die("--dest requires a path");
      destRoot = val;
      args = args.slice(2);
      continue;
    }
    if (arg === "--prefix") {
      const val = args[1];
      if (!val) die("--prefix requires a name");
      prefix = val;
      args = args.slice(2);
      continue;
    }
    break;
  }

  const repoArg = args[0];
  const targetArg = args[1] || "";
  if (!repoArg) {
    usage();
    process.exit(1);
  }

  let sourceRepo = "";
  if (isDir(repoArg)) {
    sourceRepo = repoArg;
  } else if (isDir(join(process.cwd(), repoArg))) {
    sourceRepo = join(process.cwd(), repoArg);
  } else if (isDir(join(HOME_DIR, repoArg))) {
    sourceRepo = join(HOME_DIR, repoArg);
  } else {
    die(`repo not found: ${repoArg}`);
  }

  run(["git", "-C", sourceRepo, "rev-parse", "--is-inside-work-tree"]);

  sourceRepo = realpathSync(sourceRepo);
  const baseName = basename(sourceRepo);

  if (!destRoot) {
    destRoot = DEFAULT_ROOT;
  }
  mkdirSync(destRoot, { recursive: true });
  destRoot = realpathSync(destRoot);
  destRoot = join(destRoot, baseName);

  let target = "";
  if (targetArg) {
    target = isAbsolute(targetArg) ? targetArg : join(destRoot, targetArg);
  } else {
    const base = prefix || baseName;
    let n = 1;
    while (true) {
      const candidate = join(destRoot, `${base}-${n}`);
      if (!existsSync(candidate)) {
        target = candidate;
        break;
      }
      n += 1;
    }
  }

  if (existsSync(target)) die(`target exists: ${target}`);
  mkdirSync(dirname(target), { recursive: true });

  if (mode === "copy") {
    process.stderr.write("copying (this may take a while for large repos)...\n");
    const sourceWithSlash = sourceRepo.endsWith("/") ? sourceRepo : `${sourceRepo}/`;
    const targetWithSlash = target.endsWith("/") ? target : `${target}/`;
    const rsyncPath = which("rsync");
    if (!rsyncPath) {
      die(`rsync not found. install rsync or use "${commandName()} clone --clone"`);
    }
    const rsyncArgs = ["-a"];
    if (supportsRsyncInfoProgress(rsyncPath)) {
      rsyncArgs.push("--info=progress2");
    } else {
      rsyncArgs.push("--progress");
    }
    run([rsyncPath, ...rsyncArgs, sourceWithSlash, targetWithSlash]);
  } else {
    run(["git", "clone", "--local", sourceRepo, target]);
  }

  if (target.startsWith(destRoot + "/") || target === destRoot) {
    recordCheckpoint(destRoot, basename(target));
  }

  console.log(target);
  process.exit(0);
}

if (cmd === "switch") {
  let repo = args[1];
  let nameOrNumber = args[2];
  if (!repo) {
    repo = await pickRepoInteractive();
    if (!repo) {
      process.exit(130);
    }
  }
  const baseDir = resolve(DEFAULT_ROOT, repo);
  if (!nameOrNumber) {
    const picked = await pickCheckpointInteractive(baseDir);
    if (!picked) {
      process.exit(130);
    }
    const target = join(baseDir, picked);
    if (!isDir(target)) die(`checkpoint is not a directory: ${picked}`);
    mkdirSync(baseDir, { recursive: true });
    const current = join(baseDir, "current");
    rmSync(current, { force: true });
    symlinkSync(target, current);
    mkdirSync(DEFAULT_ROOT, { recursive: true });
    writeFileSync(join(DEFAULT_ROOT, ".gc-last-switch"), `${current}\n`);
    console.log(current);
    process.exit(0);
  }
  const resolvedName = resolveName(baseDir, repo, nameOrNumber);
  const target = join(baseDir, resolvedName);
  if (!isDir(target)) die(`checkpoint is not a directory: ${resolvedName}`);
  mkdirSync(baseDir, { recursive: true });
  const current = join(baseDir, "current");
  rmSync(current, { force: true });
  symlinkSync(target, current);
  mkdirSync(DEFAULT_ROOT, { recursive: true });
  writeFileSync(join(DEFAULT_ROOT, ".gc-last-switch"), `${current}\n`);
  console.log(current);
  process.exit(0);
}

if (cmd === "delete") {
  if (args.length === 1) {
    const { baseDir, name } = resolveCheckpointFromCwd();
    removeCheckpoint(baseDir, name);
    process.stderr.write(`removed ${name}\n`);
    process.exit(0);
  }
  if (args.length >= 3) {
    const repo = args[1];
    const nameOrNumber = args[2];
    const baseDir = resolve(DEFAULT_ROOT, repo);
    const resolvedName = resolveName(baseDir, repo, nameOrNumber);
    removeCheckpoint(baseDir, resolvedName);
    process.stderr.write(`removed ${resolvedName}\n`);
    process.exit(0);
  }
  die(`usage: ${commandName()} delete [<repo> <name-or-number>]`);
}

const repo = args[1];
if (!repo) {
  usage();
  process.exit(1);
}

const baseDir = resolve(DEFAULT_ROOT, repo);

if (cmd === "list") {
  const items = listCheckpoints(baseDir);
  for (const item of items) console.log(item);
  process.exit(0);
}

if (cmd === "current") {
  const current = join(baseDir, "current");
  if (!existsSync(current)) die("current not set");
  const target = readlinkSync(current);
  console.log(target);
  process.exit(0);
}

if (cmd === "latest") {
  const items = listCheckpoints(baseDir);
  if (items.length === 0) die("no checkpoints found");
  console.log(join(baseDir, items[items.length - 1]));
  process.exit(0);
}

if (cmd === "clean") {
  let days = 90;
  let dryRun = false;

  for (let i = 2; i < args.length; i += 1) {
    const arg = args[i];
    if (arg === "--days" || arg === "--older-than") {
      const val = args[i + 1];
      if (!val) die(`${arg} requires a number`);
      days = Number(val);
      i += 1;
      continue;
    }
    if (arg === "--dry-run") {
      dryRun = true;
      continue;
    }
    if (arg === "--help" || arg === "-h") {
      usage();
      process.exit(0);
    }
  }

  if (!Number.isFinite(days) || days < 0) {
    die("--days must be a non-negative number");
  }

  const names = listCheckpoints(baseDir);
  if (names.length === 0) {
    process.stderr.write("no checkpoints found\n");
    process.exit(0);
  }

  const nameSet = new Set(names);
  const indexed = ensureIndex(baseDir, names).filter((item) => nameSet.has(item.name));
  const cutoff = Date.now() - days * 24 * 60 * 60 * 1000;

  let toRemove = indexed.filter((item) => item.mtimeMs < cutoff).map((item) => item.name);

  const currentLink = join(baseDir, "current");
  if (existsSync(currentLink)) {
    try {
      const currentTarget = readlinkSync(currentLink);
      const currentName = basename(currentTarget);
      toRemove = toRemove.filter((name) => name !== currentName);
    } catch {
      // ignore invalid symlink
    }
  }

  if (toRemove.length === 0) {
    process.stderr.write("nothing to clean\n");
    process.exit(0);
  }

  if (dryRun) {
    for (const name of toRemove) console.log(name);
    process.exit(0);
  }

  for (const name of toRemove) {
    rmSync(join(baseDir, name), { recursive: true, force: true });
  }

  const remainingNames = new Set(names.filter((name) => !toRemove.includes(name)));
  const existingIndex = loadIndex(baseDir);
  const remaining = existingIndex.items.filter((item) => remainingNames.has(item.name));
  saveIndex(baseDir, remaining);

  process.stderr.write(`removed ${toRemove.length} checkpoint(s)\n`);
  process.exit(0);
}

if (cmd === "path") {
  const nameOrNumber = args[2];
  const resolvedName = resolveName(baseDir, repo, nameOrNumber);
  console.log(join(baseDir, resolvedName));
  process.exit(0);
}

die(`unknown command: ${cmd}`);
