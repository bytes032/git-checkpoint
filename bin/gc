#!/usr/bin/env bun
import { homedir } from "os";
import { basename, dirname, isAbsolute, join, resolve } from "path";
import { existsSync, mkdirSync, readdirSync, readFileSync, readlinkSync, realpathSync, rmSync, statSync, symlinkSync, writeFileSync } from "fs";

const HOME_DIR = process.env.HOME || homedir();
const DEFAULT_ROOT = process.env.GC_ROOT || join(HOME_DIR, "checkpoints");
const CHECKPOINTS_HELP = `Checkpoints live at ${DEFAULT_ROOT}/<repo> by default.
Set GC_ROOT to change the base directory.`;
const INDEX_FILE = ".gc-index.json";

function usage() {
  const self = basename(process.argv[1] || "gc");
  console.log(`Usage:
  ${self} clone <repo-path-or-name> [target-dir]
  ${self} clone --copy <repo-path-or-name> [target-dir]
  ${self} clone --dest <dir> <repo-path-or-name> [target-dir]
  ${self} clone --prefix <name> <repo-path-or-name>
  ${self} list <repo>
  ${self} current <repo>
  ${self} switch <repo> <name-or-number>
  ${self} clean <repo> --keep <n> [--dry-run]
  ${self} path <repo> <name-or-number>
  ${self} latest <repo>

Examples:
  ${self} clone fafo
  ${self} clone --dest ${DEFAULT_ROOT} fafo
  ${self} list fafo
  ${self} switch fafo 2
  ${self} clean fafo --keep 5
  ${self} current fafo
  cd "$(${self} path fafo 2)"

Notes:
  By default clone makes a full copy (tracked + untracked + ignored). Use
  "clone --clone" for a local git clone of tracked files only.
  Default output location is ${DEFAULT_ROOT}/<repo>/<repo>-N
  (or ${DEFAULT_ROOT}/<repo>/<prefix>-N if --prefix is set).
  ${CHECKPOINTS_HELP}`);
}

function die(msg, code = 1) {
  process.stderr.write(`error: ${msg}\n`);
  process.exit(code);
}

function isDir(p) {
  try {
    return statSync(p).isDirectory();
  } catch {
    return false;
  }
}

function run(cmd, cwd) {
  const res = Bun.spawnSync({
    cmd,
    cwd,
    stdout: "pipe",
    stderr: "pipe",
  });
  if (res.exitCode !== 0) {
    if (res.stderr?.length) {
      process.stderr.write(res.stderr);
    }
    process.exit(res.exitCode || 1);
  }
  return res;
}

function listCheckpoints(baseDir) {
  if (!isDir(baseDir)) return [];
  return readdirSync(baseDir, { withFileTypes: true })
    .filter((d) => d.isDirectory() && d.name !== "current")
    .map((d) => d.name)
    .sort((a, b) => a.localeCompare(b, "en", { numeric: true }));
}

function loadIndex(baseDir) {
  const indexPath = join(baseDir, INDEX_FILE);
  if (!existsSync(indexPath)) return { items: [] };
  try {
    const data = JSON.parse(readFileSync(indexPath, "utf8"));
    if (data && Array.isArray(data.items)) return { items: data.items };
  } catch {
    // fall through to empty index
  }
  return { items: [] };
}

function saveIndex(baseDir, items) {
  const indexPath = join(baseDir, INDEX_FILE);
  const payload = { version: 1, items };
  writeFileSync(indexPath, `${JSON.stringify(payload, null, 2)}\n`);
}

function ensureIndex(baseDir, names) {
  const index = loadIndex(baseDir);
  const map = new Map(index.items.map((item) => [item.name, item]));
  let changed = false;

  for (const name of names) {
    if (map.has(name)) continue;
    try {
      const stat = statSync(join(baseDir, name));
      map.set(name, { name, createdAt: new Date(stat.mtimeMs).toISOString() });
      changed = true;
    } catch {
      map.set(name, { name, createdAt: new Date().toISOString() });
      changed = true;
    }
  }

  const items = Array.from(map.values());
  if (changed) saveIndex(baseDir, items);
  return items;
}

function recordCheckpoint(baseDir, name) {
  const index = loadIndex(baseDir);
  const now = new Date().toISOString();
  const existing = index.items.find((item) => item.name === name);
  if (existing) {
    existing.createdAt = existing.createdAt || now;
  } else {
    index.items.push({ name, createdAt: now });
  }
  saveIndex(baseDir, index.items);
}

function parseTime(value) {
  const ts = Date.parse(value || "");
  return Number.isFinite(ts) ? ts : 0;
}

function resolveName(baseDir, repo, nameOrNumber) {
  if (!nameOrNumber) die("missing checkpoint name or number");
  if (/^\d+$/.test(nameOrNumber)) {
    const candidate = `${repo}-${nameOrNumber}`;
    if (existsSync(join(baseDir, candidate))) return candidate;
  }
  if (existsSync(join(baseDir, nameOrNumber))) return nameOrNumber;
  die(`checkpoint not found: ${nameOrNumber} (try "gc list ${repo}")`);
}

const scriptName = basename(process.argv[1] || "gc");
let args = process.argv.slice(2);

if (scriptName === "gc-clone" && (args[0] !== "clone")) {
  args.unshift("clone");
}

const cmd = args[0];
if (!cmd || cmd === "-h" || cmd === "--help" || cmd === "help") {
  usage();
  process.exit(cmd ? 0 : 1);
}

if (cmd === "clone") {
  args = args.slice(1);
  let mode = "copy";
  let destRoot = "";
  let prefix = "";

  while (args.length > 0) {
    const arg = args[0];
    if (arg === "-h" || arg === "--help") {
      usage();
      process.exit(0);
    }
    if (arg === "--copy") {
      mode = "copy";
      args.shift();
      continue;
    }
    if (arg === "--clone") {
      mode = "clone";
      args.shift();
      continue;
    }
    if (arg === "--dest") {
      const val = args[1];
      if (!val) die("--dest requires a path");
      destRoot = val;
      args = args.slice(2);
      continue;
    }
    if (arg === "--prefix") {
      const val = args[1];
      if (!val) die("--prefix requires a name");
      prefix = val;
      args = args.slice(2);
      continue;
    }
    break;
  }

  const repoArg = args[0];
  const targetArg = args[1] || "";
  if (!repoArg) {
    usage();
    process.exit(1);
  }

  let sourceRepo = "";
  if (isDir(repoArg)) {
    sourceRepo = repoArg;
  } else if (isDir(join(process.cwd(), repoArg))) {
    sourceRepo = join(process.cwd(), repoArg);
  } else if (isDir(join(HOME_DIR, repoArg))) {
    sourceRepo = join(HOME_DIR, repoArg);
  } else {
    die(`repo not found: ${repoArg}`);
  }

  run(["git", "-C", sourceRepo, "rev-parse", "--is-inside-work-tree"]);

  sourceRepo = realpathSync(sourceRepo);
  const baseName = basename(sourceRepo);

  if (!destRoot) {
    destRoot = DEFAULT_ROOT;
  }
  mkdirSync(destRoot, { recursive: true });
  destRoot = realpathSync(destRoot);
  destRoot = join(destRoot, baseName);

  let target = "";
  if (targetArg) {
    target = isAbsolute(targetArg) ? targetArg : join(destRoot, targetArg);
  } else {
    const base = prefix || baseName;
    let n = 1;
    while (true) {
      const candidate = join(destRoot, `${base}-${n}`);
      if (!existsSync(candidate)) {
        target = candidate;
        break;
      }
      n += 1;
    }
  }

  if (existsSync(target)) die(`target exists: ${target}`);
  mkdirSync(dirname(target), { recursive: true });

  if (mode === "copy") {
    process.stderr.write("copying (this may take a while for large repos)...\n");
    const sourceWithSlash = sourceRepo.endsWith("/") ? sourceRepo : `${sourceRepo}/`;
    const targetWithSlash = target.endsWith("/") ? target : `${target}/`;
    const rsyncPath = Bun.which("rsync");
    if (!rsyncPath) {
      die("rsync not found. install rsync or use \"gc clone --clone\"");
    }
    run([rsyncPath, "-a", "--info=progress2", sourceWithSlash, targetWithSlash]);
  } else {
    run(["git", "clone", "--local", sourceRepo, target]);
  }

  if (target.startsWith(destRoot + "/") || target === destRoot) {
    recordCheckpoint(destRoot, basename(target));
  }

  console.log(target);
  process.exit(0);
}

const repo = args[1];
if (!repo) {
  usage();
  process.exit(1);
}

const baseDir = resolve(DEFAULT_ROOT, repo);

if (cmd === "list") {
  const items = listCheckpoints(baseDir);
  for (const item of items) console.log(item);
  process.exit(0);
}

if (cmd === "current") {
  const current = join(baseDir, "current");
  if (!existsSync(current)) die("current not set");
  const target = readlinkSync(current);
  console.log(target);
  process.exit(0);
}

if (cmd === "latest") {
  const items = listCheckpoints(baseDir);
  if (items.length === 0) die("no checkpoints found");
  console.log(join(baseDir, items[items.length - 1]));
  process.exit(0);
}

if (cmd === "clean") {
  let keep = 5;
  let dryRun = false;

  for (let i = 2; i < args.length; i += 1) {
    const arg = args[i];
    if (arg === "--keep") {
      const val = args[i + 1];
      if (!val) die("--keep requires a number");
      keep = Number(val);
      i += 1;
      continue;
    }
    if (arg === "--dry-run") {
      dryRun = true;
      continue;
    }
    if (arg === "--help" || arg === "-h") {
      usage();
      process.exit(0);
    }
  }

  if (!Number.isFinite(keep) || keep < 0 || !Number.isInteger(keep)) {
    die("--keep must be a non-negative integer");
  }

  const names = listCheckpoints(baseDir);
  if (names.length === 0) {
    process.stderr.write("no checkpoints found\n");
    process.exit(0);
  }

  const nameSet = new Set(names);
  const indexed = ensureIndex(baseDir, names).filter((item) => nameSet.has(item.name));
  const ordered = indexed.slice().sort((a, b) => parseTime(a.createdAt) - parseTime(b.createdAt));

  const removeCount = Math.max(0, ordered.length - keep);
  let toRemove = ordered.slice(0, removeCount).map((item) => item.name);

  const currentLink = join(baseDir, "current");
  if (existsSync(currentLink)) {
    try {
      const currentTarget = readlinkSync(currentLink);
      const currentName = basename(currentTarget);
      toRemove = toRemove.filter((name) => name !== currentName);
    } catch {
      // ignore invalid symlink
    }
  }

  if (toRemove.length === 0) {
    process.stderr.write("nothing to clean\n");
    process.exit(0);
  }

  if (dryRun) {
    for (const name of toRemove) console.log(name);
    process.exit(0);
  }

  for (const name of toRemove) {
    rmSync(join(baseDir, name), { recursive: true, force: true });
  }

  const remaining = ordered
    .filter((item) => !toRemove.includes(item.name))
    .map((item) => ({ name: item.name, createdAt: item.createdAt }));
  saveIndex(baseDir, remaining);

  process.stderr.write(`removed ${toRemove.length} checkpoint(s)\n`);
  process.exit(0);
}

if (cmd === "path") {
  const nameOrNumber = args[2];
  const resolvedName = resolveName(baseDir, repo, nameOrNumber);
  console.log(join(baseDir, resolvedName));
  process.exit(0);
}

if (cmd === "switch") {
  const nameOrNumber = args[2];
  const resolvedName = resolveName(baseDir, repo, nameOrNumber);
  const target = join(baseDir, resolvedName);
  if (!isDir(target)) die(`checkpoint is not a directory: ${resolvedName}`);
  mkdirSync(baseDir, { recursive: true });
  const current = join(baseDir, "current");
  rmSync(current, { force: true });
  symlinkSync(target, current);
  console.log(current);
  process.exit(0);
}

die(`unknown command: ${cmd}`);
