#!/usr/bin/env bun
import { homedir } from "os";
import { basename, dirname, isAbsolute, join, resolve } from "path";
import { existsSync, mkdirSync, readdirSync, readFileSync, readlinkSync, realpathSync, rmSync, statSync, symlinkSync, writeFileSync } from "fs";

const HOME_DIR = process.env.HOME || homedir();
const DEFAULT_ROOT = process.env.GC_ROOT || join(HOME_DIR, "checkpoints");
const CHECKPOINTS_HELP = `Checkpoints live at ${DEFAULT_ROOT}/<repo> by default.
Set GC_ROOT to change the base directory.`;
const INDEX_FILE = ".gc-index.json";

function usage() {
  const self = basename(process.argv[1] || "gc");
  console.log(`Usage:
  ${self} clone <repo-path-or-name> [target-dir]
  ${self} clone --copy <repo-path-or-name> [target-dir]
  ${self} clone --dest <dir> <repo-path-or-name> [target-dir]
  ${self} clone --prefix <name> <repo-path-or-name>
  ${self} list <repo>
  ${self} current <repo>
  ${self} switch <repo> <name-or-number>
  ${self} clean <repo> [--days <n>] [--dry-run]
  ${self} path <repo> <name-or-number>
  ${self} latest <repo>

Examples:
  ${self} clone fafo
  ${self} clone --dest ${DEFAULT_ROOT} fafo
  ${self} list fafo
  ${self} switch fafo 2
  ${self} clean fafo --days 90
  ${self} current fafo
  cd "$(${self} path fafo 2)"

Notes:
  By default clone makes a full copy (tracked + untracked + ignored). Use
  "clone --clone" for a local git clone of tracked files only.
  Default output location is ${DEFAULT_ROOT}/<repo>/<repo>-N
  (or ${DEFAULT_ROOT}/<repo>/<prefix>-N if --prefix is set).
  ${CHECKPOINTS_HELP}`);
}

function die(msg, code = 1) {
  process.stderr.write(`error: ${msg}\n`);
  process.exit(code);
}

function isDir(p) {
  try {
    return statSync(p).isDirectory();
  } catch {
    return false;
  }
}

function run(cmd, cwd) {
  const res = Bun.spawnSync({
    cmd,
    cwd,
    stdout: "pipe",
    stderr: "pipe",
  });
  if (res.exitCode !== 0) {
    if (res.stderr?.length) {
      process.stderr.write(res.stderr);
    }
    process.exit(res.exitCode || 1);
  }
  return res;
}

function listCheckpoints(baseDir) {
  if (!isDir(baseDir)) return [];
  return readdirSync(baseDir, { withFileTypes: true })
    .filter((d) => d.isDirectory() && d.name !== "current")
    .map((d) => d.name)
    .sort((a, b) => a.localeCompare(b, "en", { numeric: true }));
}

function loadIndex(baseDir) {
  const indexPath = join(baseDir, INDEX_FILE);
  if (!existsSync(indexPath)) return { items: [] };
  try {
    const data = JSON.parse(readFileSync(indexPath, "utf8"));
    if (data && Array.isArray(data.items)) return { items: data.items };
  } catch {
    // fall through to empty index
  }
  return { items: [] };
}

function saveIndex(baseDir, items) {
  const indexPath = join(baseDir, INDEX_FILE);
  const payload = { version: 1, items };
  writeFileSync(indexPath, `${JSON.stringify(payload, null, 2)}\n`);
}

function ensureIndex(baseDir, names) {
  const index = loadIndex(baseDir);
  const map = new Map(index.items.map((item) => [item.name, item]));
  let changed = false;
  const info = [];

  for (const name of names) {
    let mtimeMs = 0;
    try {
      const stat = statSync(join(baseDir, name));
      mtimeMs = stat.mtimeMs;
    } catch {
      mtimeMs = Date.now();
    }

    const existing = map.get(name);
    const createdAt = existing?.createdAt || new Date(mtimeMs).toISOString();
    const lastModified = new Date(mtimeMs).toISOString();

    if (!existing || !existing.createdAt || existing.lastModified !== lastModified) {
      map.set(name, { name, createdAt, lastModified });
      changed = true;
    }

    info.push({ name, createdAt, lastModified, mtimeMs });
  }

  const items = Array.from(map.values());
  if (changed) saveIndex(baseDir, items);
  return info;
}

function recordCheckpoint(baseDir, name) {
  const index = loadIndex(baseDir);
  const now = new Date().toISOString();
  const existing = index.items.find((item) => item.name === name);
  if (existing) {
    existing.createdAt = existing.createdAt || now;
    existing.lastModified = now;
  } else {
    index.items.push({ name, createdAt: now, lastModified: now });
  }
  saveIndex(baseDir, index.items);
}

function formatAge(ms) {
  const seconds = Math.max(0, Math.floor(ms / 1000));
  if (seconds < 60) return `${seconds}s ago`;
  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) return `${minutes}m ago`;
  const hours = Math.floor(minutes / 60);
  if (hours < 48) return `${hours}h ago`;
  const days = Math.floor(hours / 24);
  if (days < 30) return `${days}d ago`;
  const months = Math.floor(days / 30);
  if (months < 24) return `${months}mo ago`;
  const years = Math.floor(months / 12);
  return `${years}y ago`;
}

function listWithActivity(baseDir) {
  const names = listCheckpoints(baseDir);
  if (names.length === 0) {
    process.stderr.write("no checkpoints found\n");
    return;
  }
  const nameSet = new Set(names);
  const indexed = ensureIndex(baseDir, names).filter((item) => nameSet.has(item.name));
  const now = Date.now();
  const currentLink = join(baseDir, "current");
  let currentName = "";
  if (existsSync(currentLink)) {
    try {
      currentName = basename(readlinkSync(currentLink));
    } catch {
      currentName = "";
    }
  }
  for (const item of indexed.sort((a, b) => a.name.localeCompare(b.name, "en", { numeric: true }))) {
    const age = formatAge(now - item.mtimeMs);
    const stamp = item.lastModified || new Date(item.mtimeMs).toISOString();
    const mark = item.name === currentName ? "*" : " ";
    console.log(`${mark} ${item.name}  ${age}  (${stamp})`);
  }
}

function resolveName(baseDir, repo, nameOrNumber) {
  if (!nameOrNumber) die("missing checkpoint name or number");
  if (/^\d+$/.test(nameOrNumber)) {
    const candidate = `${repo}-${nameOrNumber}`;
    if (existsSync(join(baseDir, candidate))) return candidate;
  }
  if (existsSync(join(baseDir, nameOrNumber))) return nameOrNumber;
  die(`checkpoint not found: ${nameOrNumber} (try "gc list ${repo}")`);
}

const scriptName = basename(process.argv[1] || "gc");
let args = process.argv.slice(2);

if (scriptName === "gc-clone" && (args[0] !== "clone")) {
  args.unshift("clone");
}

const cmd = args[0];
if (!cmd || cmd === "-h" || cmd === "--help" || cmd === "help") {
  usage();
  process.exit(cmd ? 0 : 1);
}

if (cmd === "clone") {
  args = args.slice(1);
  let mode = "copy";
  let destRoot = "";
  let prefix = "";

  while (args.length > 0) {
    const arg = args[0];
    if (arg === "-h" || arg === "--help") {
      usage();
      process.exit(0);
    }
    if (arg === "--copy") {
      mode = "copy";
      args.shift();
      continue;
    }
    if (arg === "--clone") {
      mode = "clone";
      args.shift();
      continue;
    }
    if (arg === "--dest") {
      const val = args[1];
      if (!val) die("--dest requires a path");
      destRoot = val;
      args = args.slice(2);
      continue;
    }
    if (arg === "--prefix") {
      const val = args[1];
      if (!val) die("--prefix requires a name");
      prefix = val;
      args = args.slice(2);
      continue;
    }
    break;
  }

  const repoArg = args[0];
  const targetArg = args[1] || "";
  if (!repoArg) {
    usage();
    process.exit(1);
  }

  let sourceRepo = "";
  if (isDir(repoArg)) {
    sourceRepo = repoArg;
  } else if (isDir(join(process.cwd(), repoArg))) {
    sourceRepo = join(process.cwd(), repoArg);
  } else if (isDir(join(HOME_DIR, repoArg))) {
    sourceRepo = join(HOME_DIR, repoArg);
  } else {
    die(`repo not found: ${repoArg}`);
  }

  run(["git", "-C", sourceRepo, "rev-parse", "--is-inside-work-tree"]);

  sourceRepo = realpathSync(sourceRepo);
  const baseName = basename(sourceRepo);

  if (!destRoot) {
    destRoot = DEFAULT_ROOT;
  }
  mkdirSync(destRoot, { recursive: true });
  destRoot = realpathSync(destRoot);
  destRoot = join(destRoot, baseName);

  let target = "";
  if (targetArg) {
    target = isAbsolute(targetArg) ? targetArg : join(destRoot, targetArg);
  } else {
    const base = prefix || baseName;
    let n = 1;
    while (true) {
      const candidate = join(destRoot, `${base}-${n}`);
      if (!existsSync(candidate)) {
        target = candidate;
        break;
      }
      n += 1;
    }
  }

  if (existsSync(target)) die(`target exists: ${target}`);
  mkdirSync(dirname(target), { recursive: true });

  if (mode === "copy") {
    process.stderr.write("copying (this may take a while for large repos)...\n");
    const sourceWithSlash = sourceRepo.endsWith("/") ? sourceRepo : `${sourceRepo}/`;
    const targetWithSlash = target.endsWith("/") ? target : `${target}/`;
    const rsyncPath = Bun.which("rsync");
    if (!rsyncPath) {
      die("rsync not found. install rsync or use \"gc clone --clone\"");
    }
    run([rsyncPath, "-a", "--info=progress2", sourceWithSlash, targetWithSlash]);
  } else {
    run(["git", "clone", "--local", sourceRepo, target]);
  }

  if (target.startsWith(destRoot + "/") || target === destRoot) {
    recordCheckpoint(destRoot, basename(target));
  }

  console.log(target);
  process.exit(0);
}

const repo = args[1];
if (!repo) {
  usage();
  process.exit(1);
}

const baseDir = resolve(DEFAULT_ROOT, repo);

if (cmd === "list") {
  const items = listCheckpoints(baseDir);
  for (const item of items) console.log(item);
  process.exit(0);
}

if (cmd === "current") {
  const current = join(baseDir, "current");
  if (!existsSync(current)) die("current not set");
  const target = readlinkSync(current);
  console.log(target);
  process.exit(0);
}

if (cmd === "latest") {
  const items = listCheckpoints(baseDir);
  if (items.length === 0) die("no checkpoints found");
  console.log(join(baseDir, items[items.length - 1]));
  process.exit(0);
}

if (cmd === "clean") {
  let days = 90;
  let dryRun = false;

  for (let i = 2; i < args.length; i += 1) {
    const arg = args[i];
    if (arg === "--days" || arg === "--older-than") {
      const val = args[i + 1];
      if (!val) die(`${arg} requires a number`);
      days = Number(val);
      i += 1;
      continue;
    }
    if (arg === "--dry-run") {
      dryRun = true;
      continue;
    }
    if (arg === "--help" || arg === "-h") {
      usage();
      process.exit(0);
    }
  }

  if (!Number.isFinite(days) || days < 0) {
    die("--days must be a non-negative number");
  }

  const names = listCheckpoints(baseDir);
  if (names.length === 0) {
    process.stderr.write("no checkpoints found\n");
    process.exit(0);
  }

  const nameSet = new Set(names);
  const indexed = ensureIndex(baseDir, names).filter((item) => nameSet.has(item.name));
  const cutoff = Date.now() - days * 24 * 60 * 60 * 1000;

  let toRemove = indexed.filter((item) => item.mtimeMs < cutoff).map((item) => item.name);

  const currentLink = join(baseDir, "current");
  if (existsSync(currentLink)) {
    try {
      const currentTarget = readlinkSync(currentLink);
      const currentName = basename(currentTarget);
      toRemove = toRemove.filter((name) => name !== currentName);
    } catch {
      // ignore invalid symlink
    }
  }

  if (toRemove.length === 0) {
    process.stderr.write("nothing to clean\n");
    process.exit(0);
  }

  if (dryRun) {
    for (const name of toRemove) console.log(name);
    process.exit(0);
  }

  for (const name of toRemove) {
    rmSync(join(baseDir, name), { recursive: true, force: true });
  }

  const remainingNames = new Set(names.filter((name) => !toRemove.includes(name)));
  const existingIndex = loadIndex(baseDir);
  const remaining = existingIndex.items.filter((item) => remainingNames.has(item.name));
  saveIndex(baseDir, remaining);

  process.stderr.write(`removed ${toRemove.length} checkpoint(s)\n`);
  process.exit(0);
}

if (cmd === "path") {
  const nameOrNumber = args[2];
  const resolvedName = resolveName(baseDir, repo, nameOrNumber);
  console.log(join(baseDir, resolvedName));
  process.exit(0);
}

if (cmd === "switch") {
  const nameOrNumber = args[2];
  if (!nameOrNumber) {
    listWithActivity(baseDir);
    process.exit(0);
  }
  const resolvedName = resolveName(baseDir, repo, nameOrNumber);
  const target = join(baseDir, resolvedName);
  if (!isDir(target)) die(`checkpoint is not a directory: ${resolvedName}`);
  mkdirSync(baseDir, { recursive: true });
  const current = join(baseDir, "current");
  rmSync(current, { force: true });
  symlinkSync(target, current);
  console.log(current);
  process.exit(0);
}

die(`unknown command: ${cmd}`);
